#!/usr/bin/env ruby

require "base64"
require "digest/sha1"
require "fileutils"
require "logger"
require "pathname"
require "time"

require "rubygems"
require "haml"
require "nanoc3"
require "sinatra"
require "nokogiri"

include FileUtils

LOCAL_SERVER_NAME = `hostname`.strip + ":4567"

ALL_POSTS = Hash.new do |hash, sha1|
  post = BLOG_SITE.article_by_sha1(sha1)
  rep = post.rep_named(:default)
  unless rep.compiled?
    BLOG_SITE.compiler.run(post, :force => true)
  end
  content = rep.compiled_content
  hash[sha1] = content
end

class Nanoc3::Site
  def article_by_sha1(sha1)
    self.items.find {|x| x.article? && x[:sha1] == sha1}
  end
end

class Nanoc3::Item
  def wordpress_post_status
    case self.identifier
    when /^\/posts\//
      "publish"
    when /^\/drafts\//
      "draft"
    end
  end
end

configure do
  LOGGER = Logger.new(STDOUT)

  Dir.chdir(File.join(File.dirname(__FILE__), "..")) do
    BLOG_SITE = Nanoc3::Site.new('.')
  end

  BLOG_SITE.load_data
  LOGGER.debug("Compiling nanoc3 site...")
  BLOG_SITE.compiler.run
  LOGGER.debug("nanoc3 compilation completed")

  set :static
  set :public, File.join(File.dirname(__FILE__), "..", "output")
  set :views, File.join(File.dirname(__FILE__), "..", "server", "views")
end

helpers do
  def logger
    LOGGER
  end

  def value_for_node(node)
    actual = node.children.find {|x| x.name != "text"}
    case actual.name
    when "array"
      node['data'].first.children.map do |node|
        value_for_node(value)
      end
    when "base64"
      Base64.decode64(node.content.strip)
    when "boolean"
      node.content.strip == "1"
    when "dateTime.iso8601"
      Time.iso8601(node.content.strip)
    when "double"
      node.content.strip.to_f
    when "int", "i4"
      node.content.strip.to_i
    when "string"
      node.content.strip
    when "struct"
      hash = {}
      (node / 'member').each do |member|
        name = (member/'name').first.content.strip
        value = value_for_node((member/'value').first)
        hash[name.to_sym] = value
      end
      hash
    when "nil"
      nil
    end
  end

  def parse_parameters(xml)
    params = xml.xpath('/methodCall/params/param/value').map do |param|
      value_for_node(param)
    end
    LOGGER.debug("Incoming parameters: #{params.inspect}")
    params
  end

  def get_recent_posts(max_items)
    recent_posts = BLOG_SITE.articles[0..max_items]
    haml :metaweblog_get_recent_posts, :locals => { :recent_posts => recent_posts }
  end

  def add_post(new_post, publish, respond=true)
    LOGGER.debug("new post: #{new_post.inspect} publish? #{publish}")
    title = new_post[:title]
    body = new_post[:description];
    sha1 = new_post[:sha1] || Digest::SHA1.hexdigest(body)
    created_at = Time.now
    permalink = title.gsub(" ", "-").downcase
    identifier = sprintf("/#{publish ? "posts" : "drafts"}/%04d/%02d/%02d/%s/",
                         created_at.year,
                         created_at.month,
                         created_at.day,
                         permalink)
    attrs = {
      :kind       => "article",
      :permalink  => permalink,
      :title      => title,
      :created_at => created_at,
      :tags       => Array(new_post[:mt_keywords].split(",")),
      :sha1       => sha1
    }

    BLOG_SITE.data_sources.first.create_item(body, attrs, identifier)
    BLOG_SITE.load_data(true)
    item = BLOG_SITE.article_by_sha1(sha1)
    BLOG_SITE.compiler.run(item)

    if respond
      haml :new_post, :locals => {:new_post_id => sha1}
    end
  end

  def edit_post(post_id, struct, publish)
    original_item = BLOG_SITE.article_by_sha1(post_id)
    # TODO: handle title changes
    title = struct[:title]
    body = struct[:description];
    created_at = Time.now
    attrs = original_item.attributes.merge({
      :title      => title,
      :created_at => created_at,
      :tags       => Array(struct[:mt_keywords].split(",")),
    })

    path = "content#{original_item.path}".sub(/\/$/, ".html")

    LOGGER.debug("publish? #{publish} status: #{original_item.wordpress_post_status}")
    if (publish && original_item.wordpress_post_status == "draft") ||
       (!publish && original_item.wordpress_post_status == "publish")
      file_path = File.join(File.dirname(__FILE__), "..", "content", original_item.path).sub(/\/$/, ".html")
      rm(file_path)
      add_post(struct.merge({:sha1 => attrs[:sha1]}), publish, false)
      BLOG_SITE.load_data(true)
    else
      File.open(path, 'w') do |io|
        io.write(YAML.dump(attrs).strip + "\n")
        io.write("---\n\n")
        io.write(body)
      end
    end

    ALL_POSTS.delete(post_id)

    haml :okay
  end

  def new_media_object(name, type, bits)
    now = Date.today
    path = now.strftime("public/images/%Y/%m/#{name}").gsub("//", "/")
    url = path.sub(/^public/, '')
    final_path = Pathname.new(File.join(File.dirname(__FILE__), "..", path))
    mkdir_p(final_path.parent) unless final_path.parent.directory?
    open(final_path, "w") {|f| f.write(bits) }

    # need to sync our public directory to the output directory where we serve
    # static content from
    system "rsync -gprt --partial public/ output"

    haml :new_media_object, :locals => { :file => final_path.realpath, :url => url, :type => type}
  end
end

get "/" do
  html = File.read(File.join(settings.public, "index.html"))
  # TODO: figure out our listener port dynamically
  html.sub("</head>", 
           %Q[<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://#{LOCAL_SERVER_NAME}/xmlrpc.php?rsd" />
<link rel="pingback" href="http://#{LOCAL_SERVER_NAME}/xmlrpc.php" /></head>]).gsub('alexvollmer.com', LOCAL_SERVER_NAME)
end

get "/xmlrpc.php" do
  haml :rsd
end

post "/xmlrpc.php" do
  xml = Nokogiri::XML.parse(request.body)
  method_call = xml.xpath("/methodCall/methodName").to_a[0].content
  api_name, method = method_call.split('.')
  response["Content-Type"] = "text/xml"
  logger.debug("api_name=#{api_name} method=#{method}")
  case api_name
  when "mt"
    case method
    when "supportedTextFilters", "getPostCategories"
      haml :empty
    end
  when "metaWeblog"
    case method
    when "editPost"
      post_id, username, password, struct, publish = parse_parameters(xml)
      edit_post(post_id, struct, publish)
    when "getPost"
      post_id, username, password = parse_parameters(xml)
      post = BLOG_SITE.articles.find {|x| x[:sha1] == post_id}
      haml :metaweblog_get_post, :locals => {:post => post}
    when "getRecentPosts"
      blog_id, username, password, max_posts = parse_parameters(xml)
      get_recent_posts(max_posts)
    when "newMediaObject"
      blog_id, username, password, struct = parse_parameters(xml)
      new_media_object(struct[:name], struct[:type], struct[:bits])
    when "newPost"
      blog_id, username, password, struct, publish = parse_parameters(xml)
      add_post(struct, publish == "1")
    end
  when "wp"
    case method
    when "getCategories"
      haml :wp_get_categories
    when "getPages"
      haml :wp_get_pages
    end
  else
    # TODO: then what?
  end
end

