#!/usr/bin/env ruby

require "base64"
require "digest/sha1"
require "fileutils"
require "logger"
require "pathname"
require "time"
require "xmlrpc/marshal"
require "xmlrpc/server"

require "rubygems"
require "haml"
require "nanoc3"
require "sinatra"
require "nokogiri"

include FileUtils

LOCAL_SERVER_NAME = `hostname`.strip + ":4567"

ALL_POSTS = Hash.new do |hash, sha1|
  post = BLOG_SITE.article_by_sha1(sha1)
  rep = post.rep_named(:default)
  unless rep.compiled?
    BLOG_SITE.compiler.run(post, :force => true)
  end
  content = rep.compiled_content
  hash[sha1] = content
end

class Nanoc3::Site
  def article_by_sha1(sha1)
    self.items.find {|x| x.article? && x[:sha1] == sha1}
  end
end

class Nanoc3::Item
  def wordpress_post_status
    case self.identifier
    when /^\/posts\//
      "publish"
    when /^\/drafts\//
      "draft"
    end
  end

  def xmlrpc_hash
    {
      :dateCreated       => self.created_at,
      :userid            => "1",
      :postid            => self[:sha1],
      :description       => ALL_POSTS[self[:sha1]],
      :title             => self.title,
      :link              => "http://#{LOCAL_SERVER_NAME}#{self.path}",
      :permaLink         => "http://#{LOCAL_SERVER_NAME}#{self.path}",
      :categories        => ["Uncategorized"],
      :mt_excerpt        => "",
      :mt_text_more      => "",
      :mt_allow_comments => 1,
      :mt_allow_pings    => 0,
      :mt_keywords       => Array(self.tags).join(', '),
      :wp_slug           => self.permalink,
      :wp_password       => "",
      :wp_author_id      => "alexvollmer",
      :wp_author_display => "Alex Vollmer",
      :date_created_gmt  => self.created_at,
      :post_status       => self.wordpress_post_status,
      :custom_fields     => [],
      :wp_post_format    => "standard"
    }
  end
end

configure do
  LOGGER = Logger.new(STDOUT)

  Dir.chdir(File.join(File.dirname(__FILE__), "..")) do
    BLOG_SITE = Nanoc3::Site.new('.')
  end

  BLOG_SITE.load_data
  LOGGER.debug("Compiling nanoc3 site...")
  BLOG_SITE.compiler.run
  LOGGER.debug("nanoc3 compilation completed")

  set :static
  set :public, File.join(File.dirname(__FILE__), "..", "output")
  set :views, File.join(File.dirname(__FILE__), "..", "server", "views")

  SERVER = XMLRPC::BasicServer.new
  SERVER.add_handler("wp.getCategories") do |blog_id, username, password|
    [
      {
        '"categoryId"'  => '"1"',
        '"parentId"'    => '"0"',
        '"description"' => '"Uncategorized"',
        '"htmlUrl"'     => %Q["http://#{LOCAL_SERVER_NAME}/category/uncategorized/"],
        '"rssUrl"'      => %Q["http://#{LOCAL_SERVER_NAME}/category/uncategorized/feed/"]
      }
    ]
  end

  SERVER.add_handler("blogger.deletePost") do |app_key, post_id, username, password, publish|
    delete_post(post_id)
    1
  end

  SERVER.add_handler("mt.supportedTextFilters") do
    []
  end

  SERVER.add_handler("metaWeblog.editPost") do |post_id, username, password, struct, publish|
    edit_post(post_id, struct, publish)
    1
  end

  SERVER.add_handler("metaWeblog.getPost") do |post_id, username, password|
    BLOG_SITE.articles.find {|x| x[:sha1] == post_id}.xmlrpc_hash
  end

  SERVER.add_handler("metaWeblog.getRecentPosts") do |blog_id, username, password, max|
    BLOG_SITE.articles[0..max].map {|i| i.xmlrpc_hash}
  end

  SERVER.add_handler("metaWeblog.newMediaObject") do |blog_id, username, password, struct|
    new_media_object(name, type, struct["bits"])
    1
  end

  SERVER.add_handler("metaWeblog.newPost") do |blog_id, username, password, struct, publish|
    add_post(struct, publish)
  end

  SERVER.add_handler("mt.getPostCategories") do
    [
      {
        '"categoryId"'  => '"1"',
        '"parentId"'    => '"0"',
        '"description"' => '"Uncategorized"',
        '"htmlUrl"'     => %Q["http://#{LOCAL_SERVER_NAME}/category/uncategorized/"],
        '"rssUrl"'      => %Q["http://#{LOCAL_SERVER_NAME}/category/uncategorized/feed/"]
      }
    ]
  end

  SERVER.add_handler("wp.getPages") do |blog_id, username, password, max|
    BLOG_SITE.articles[0..max].map {|i| i.xmlrpc_hash}
  end

  SERVER.add_handler("wp.getTags") do |blog_id, username, password|
    count_tags(BLOG_SITE.articles).map do |tag, count|
      {
        :tag_id   => tag,
        :name     => tag,
        :count    => count,
        :slug     => tag,
        :html_url => "http://alexvollmer.com/tags/#{tag}/"
        #:rss_url?
      }
    end
  end
end

helpers do
  def logger
    LOGGER
  end

  def get_recent_posts(max_items)
    recent_posts = BLOG_SITE.articles[0..max_items]
    haml :metaweblog_get_recent_posts, :locals => { :recent_posts => recent_posts }
  end

  def add_post(new_post, publish)
    LOGGER.debug("new post: #{new_post.inspect} publish? #{publish}")
    title = new_post[:title]
    body = new_post[:description];
    sha1 = new_post[:sha1] || Digest::SHA1.hexdigest(body)
    created_at = Time.now
    permalink = title.gsub(" ", "-").downcase
    identifier = sprintf("/#{publish ? "posts" : "drafts"}/%04d/%02d/%02d/%s/",
                         created_at.year,
                         created_at.month,
                         created_at.day,
                         permalink)
    attrs = {
      :kind       => "article",
      :permalink  => permalink,
      :title      => title,
      :created_at => created_at,
      :tags       => Array(new_post[:mt_keywords].split(",")),
      :sha1       => sha1
    }

    BLOG_SITE.data_sources.first.create_item(body, attrs, identifier)
    BLOG_SITE.load_data(true)
    item = BLOG_SITE.article_by_sha1(sha1)
    BLOG_SITE.compiler.run(item)

    sha1
  end

  def edit_post(post_id, struct, publish)
    original_item = BLOG_SITE.article_by_sha1(post_id)
    # TODO: handle title changes
    title = struct[:title]
    body = struct[:description];
    created_at = Time.now
    attrs = original_item.attributes.merge({
      :title      => title,
      :created_at => created_at,
      :tags       => Array(struct[:mt_keywords].split(",")),
    })

    path = "content#{original_item.path}".sub(/\/$/, ".html")

    LOGGER.debug("publish? #{publish} status: #{original_item.wordpress_post_status}")
    if (publish && original_item.wordpress_post_status == "draft") ||
       (!publish && original_item.wordpress_post_status == "publish")
      file_path = File.join(File.dirname(__FILE__), "..", "content", original_item.path).sub(/\/$/, ".html")
      rm(file_path)
      add_post(struct.merge({:sha1 => attrs[:sha1]}), publish, false)
      BLOG_SITE.load_data(true)
    else
      File.open(path, 'w') do |io|
        io.write(YAML.dump(attrs).strip + "\n")
        io.write("---\n\n")
        io.write(body)
      end
    end

    ALL_POSTS.delete(post_id)
  end

  def delete_post(post_id)
    item = BLOG_SITE.article_by_sha1(post_id)
    ALL_POSTS.delete(post_id)
    BLOG_SITE.items.delete(item)
    filename = item.path.sub(/\/$/, ".html")
    path = Pathname.new(File.join(File.dirname(__FILE__), "..", "content", filename)).realpath
    rm_f(path)
  end

  def new_media_object(name, type, bits)
    now = Date.today
    path = now.strftime("public/images/%Y/%m/#{name}").gsub("//", "/")
    url = path.sub(/^public/, '')
    final_path = Pathname.new(File.join(File.dirname(__FILE__), "..", path))
    mkdir_p(final_path.parent) unless final_path.parent.directory?
    open(final_path, "w") {|f| f.write(bits) }

    # need to sync our public directory to the output directory where we serve
    # static content from
    system "rsync -gprt --partial public/ output"

    {
      :file => file,
      :url  => url,
      :type => type
    }
  end
end

get "/" do
  html = File.read(File.join(settings.public, "index.html"))
  # TODO: figure out our listener port dynamically
  html.sub("</head>", 
           %Q[<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://#{LOCAL_SERVER_NAME}/xmlrpc.php?rsd" />
<link rel="pingback" href="http://#{LOCAL_SERVER_NAME}/xmlrpc.php" /></head>]).gsub('alexvollmer.com', LOCAL_SERVER_NAME)
end

get "/xmlrpc.php" do
  haml :rsd
end

post "/xmlrpc.php" do
  method_call, args = XMLRPC::Marshal.load_call(request.body)
  api_name, method = method_call.split(".")
  response["Content-Type"] = "text/xml"
  logger.debug("api_name=#{api_name} method=#{method} args=#{args.inspect}")

  request.body.rewind
  SERVER.process(request.body)
  # case api_name
  # when "blogger"
  #   case method
  #   when "deletePost"
  #     delete_post(args[1])
  #   end
  # when "mt"
  #   case method
  #   when "supportedTextFilters", "getPostCategories"
  #     haml :empty
  #   end
  # when "metaWeblog"
  #   case method
  #   when "editPost"
  #     edit_post(args[0], args[3].symbolize_keys, args[4])
  #   when "getPost"
  #     post = BLOG_SITE.articles.find {|x| x[:sha1] == args[0]}
  #     haml :metaweblog_get_post, :locals => {:post => post}
  #   when "getRecentPosts"
  #     get_recent_posts(args[3])
  #   when "newMediaObject"
  #     struct = args[3].symbolize_keys
  #     new_media_object(struct[:name], struct[:type], struct[:bits])
  #   when "newPost"
  #     add_post(args[3].symbolize_keys, args[4])
  #   end
  # when "wp"
  #   case method
  #   when "getCategories"
  #     request.body.rewind
  #     SERVER.process(request.body)
  #     # haml :wp_get_categories
  #   when "getPages"
  #     haml :wp_get_pages
  #   end
  # else
  #   # TODO: then what?
  # end
end

