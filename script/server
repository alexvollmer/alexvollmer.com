#!/usr/bin/env ruby

require "base64"
require "digest/sha1"
require "fileutils"
require "logger"
require "pathname"
require "time"
require "xmlrpc/marshal"
require "xmlrpc/server"

require "rubygems"
require "grit"
require "haml"
require "nanoc3"
require "sinatra"

include FileUtils

LOCAL_SERVER_NAME = `hostname`.strip + ":4567"
ROOT_DIR = Pathname.new(File.join(File.dirname(__FILE__), "..")).realpath

ALL_POSTS = Hash.new do |hash, sha1|
  post = BLOG_SITE.article_by_sha1(sha1)
  rep = post.rep_named(:default)
  unless rep.compiled?
    BLOG_SITE.compiler.run(post, :force => true)
  end
  content = rep.compiled_content
  hash[sha1] = content
end

class Nanoc3::Site
  def article_by_sha1(sha1)
    self.items.find {|x| x.article? && x[:sha1] == sha1}
  end
end

class Nanoc3::Item
  def wordpress_post_status
    case self.identifier
    when /^\/posts\//
      "publish"
    when /^\/drafts\//
      "draft"
    end
  end

  def xmlrpc_hash
    {
      :dateCreated       => self.created_at,
      :userid            => "1",
      :postid            => self[:sha1],
      :description       => ALL_POSTS[self[:sha1]],
      :title             => self.title,
      :link              => "http://#{LOCAL_SERVER_NAME}#{self.path}",
      :permaLink         => "http://#{LOCAL_SERVER_NAME}#{self.path}",
      :categories        => ["Uncategorized"],
      :mt_excerpt        => "",
      :mt_text_more      => "",
      :mt_allow_comments => 1,
      :mt_allow_pings    => 0,
      :mt_keywords       => Array(self.tags).join(', '),
      :wp_slug           => self.permalink,
      :wp_password       => "",
      :wp_author_id      => "alexvollmer",
      :wp_author_display => "Alex Vollmer",
      :date_created_gmt  => self.created_at,
      :post_status       => self.wordpress_post_status,
      :custom_fields     => [],
      :wp_post_format    => "standard"
    }
  end
end

class Hash
  def symbolize_keys
    self.inject({}) {|h,kv| h[kv[0].to_sym] = kv[1]; h}
  end
end

class Nanoc3Server < XMLRPC::BasicServer
  attr_accessor :site, :repo

  def initialize(site)
    super

    self.site = site
    self.repo = Grit::Repo.new(ROOT_DIR)

    add_handler("wp.getCategories") do |blog_id, username, password|
      [
        {
          :categoryId  => 1,
          :parentId    => 0,
          :description => "Uncategorized",
          :htmlUrl     => "http://#{LOCAL_SERVER_NAME}/category/uncategorized/",
          :rssUrl      => "http://#{LOCAL_SERVER_NAME}/category/uncategorized/feed/"
        }
      ]
    end

    add_handler("blogger.deletePost") do |app_key, post_id, username, password, publish|
      delete_post(post_id)
      1
    end

    add_handler("mt.supportedTextFilters") do
      []
    end

    add_handler("metaWeblog.editPost") do |post_id, username, password, struct, publish|
      edit_post(post_id, struct.symbolize_keys, publish)
      1
    end

    add_handler("metaWeblog.getPost") do |post_id, username, password|
      BLOG_SITE.articles.find {|x| x[:sha1] == post_id}.xmlrpc_hash
    end

    add_handler("metaWeblog.getRecentPosts") do |blog_id, username, password, max|
      BLOG_SITE.articles[0..max].map {|i| i.xmlrpc_hash}
    end

    add_handler("metaWeblog.newMediaObject") do |blog_id, username, password, struct|
      new_media_object(struct["name"], struct["type"], struct["bits"])
    end

    add_handler("metaWeblog.newPost") do |blog_id, username, password, struct, publish|
      add_post(struct.symbolize_keys, publish)
    end

    add_handler("mt.getPostCategories") do
      []
    end

    add_handler("wp.getPages") do |blog_id, username, password, max|
      []
    end

    add_handler("wp.getTags") do |blog_id, username, password|
      count_tags(BLOG_SITE.articles).map do |tag, count|
        {
          :tag_id   => tag,
          :name     => tag,
          :count    => count,
          :slug     => tag,
          :html_url => "http://alexvollmer.com/tags/#{tag}/"
          #:rss_url?
        }
      end
    end
  end

  def add_post(new_post, publish)
    LOGGER.debug("new post: #{new_post.inspect} publish? #{publish}")
    title = new_post[:title]
    body = new_post[:description];
    sha1 = new_post[:sha1] || Digest::SHA1.hexdigest(body)
    created_at = Time.now
    permalink = title.gsub(" ", "-").downcase
    identifier = sprintf("/#{publish ? "posts" : "drafts"}/%04d/%02d/%02d/%s/",
                         created_at.year,
                         created_at.month,
                         created_at.day,
                         permalink)
    attrs = {
      :kind       => "article",
      :permalink  => permalink,
      :title      => title,
      :created_at => created_at,
      :tags       => Array(new_post[:mt_keywords].split(",")),
      :sha1       => sha1
    }

    site.data_sources.first.create_item(body, attrs, identifier)
    site.load_data(true)
    item = site.article_by_sha1(sha1)
    site.compiler.run(item)

    self.repo.add(ROOT_DIR + "content", ROOT_DIR + "public")
    self.repo.commit_all("Added post '#{title}'")

    sha1
  end

  def edit_post(post_id, struct, publish)
    original_item = site.article_by_sha1(post_id)
    # TODO: handle title changes
    title = struct[:title]
    body = struct[:description];
    created_at = Time.now
    attrs = original_item.attributes.merge({
      :title      => title,
      :created_at => created_at,
      :tags       => Array(struct[:mt_keywords].split(",")),
    })
    attrs.delete(:file)  # avoid a warning from nanoc3

    path = "content#{original_item.path}".sub(/\/$/, ".html")

    LOGGER.debug("publish? #{publish} status: #{original_item.wordpress_post_status}")
    if (publish && original_item.wordpress_post_status == "draft") ||
       (!publish && original_item.wordpress_post_status == "publish")
      file_path = (ROOT_DIR + "content" + original_item.path).sub(/\/$/, ".html")
      rm(file_path)
      self.repo.remove(file_path)
      struct[:sha1] = attrs[:sha1]
      add_post(struct, publish)
      site.load_data(true)
    else
      File.open(path, 'w') do |io|
        io.write(YAML.dump(attrs).strip + "\n")
        io.write("---\n\n")
        io.write(body)
      end

      self.repo.add(ROOT_DIR + "content", ROOT_DIR + "public")
      self.repo.commit_all("Updated post '#{title}'")
    end

    ALL_POSTS.delete(post_id)
  end

  def delete_post(post_id)
    item = site.article_by_sha1(post_id)
    ALL_POSTS.delete(post_id)
    site.items.delete(item)
    filename = item.path.sub(/\/$/, ".html")
    path = (ROOT_DIR + "content" + filename.sub(/^\//, "")).realpath
    rm_f(path)

    self.repo.remove(path)
    self.repo.commit_all("Removed post '#{item[:title]}")
  end

  def new_media_object(name, file_type, bits)
    now = Date.today
    path = now.strftime("public/images/%Y/%m/#{name}").gsub("//", "/")
    url = path.sub(/^public/, '')
    final_path = ROOT_DIR + path
    mkdir_p(final_path.parent) unless final_path.parent.directory?
    open(final_path, "w") {|f| f.write(bits) }

    # need to sync our public directory to the output directory where we serve
    # static content from
    system "rsync -gprt --partial public/ output"

    {
      :file => final_path.to_s,
      :url  => url,
      :type => file_type
    }
  end
end

configure do
  LOGGER = Logger.new(STDOUT)

  Dir.chdir(File.join(File.dirname(__FILE__), "..")) do
    BLOG_SITE = Nanoc3::Site.new('.')
  end

  BLOG_SITE.load_data
  LOGGER.debug("Compiling nanoc3 site...")
  BLOG_SITE.compiler.run
  LOGGER.debug("nanoc3 compilation completed")

  set :static
  set :public, File.join(File.dirname(__FILE__), "..", "output")
  set :views, File.join(File.dirname(__FILE__), "..", "server", "views")

  SERVER = Nanoc3Server.new(BLOG_SITE)
end

helpers do
  def logger
    LOGGER
  end
end

get "/" do
  html = File.read(File.join(settings.public, "index.html"))
  # TODO: figure out our listener port dynamically
  html.sub("</head>", 
           %Q[<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://#{LOCAL_SERVER_NAME}/xmlrpc.php?rsd" />
<link rel="pingback" href="http://#{LOCAL_SERVER_NAME}/xmlrpc.php" /></head>]).gsub('alexvollmer.com', LOCAL_SERVER_NAME)
end

get "/xmlrpc.php" do
  haml :rsd
end

post "/xmlrpc.php" do
  method_call, args = XMLRPC::Marshal.load_call(request.body)
  api_name, method = method_call.split(".")
  response["Content-Type"] = "text/xml"
  # logger.debug("api_name=#{api_name} method=#{method} args=#{args.inspect}")

  request.body.rewind
  SERVER.process(request.body)
end

